shared:
  secretRef:
  image:
  serverHostname:

server:
  replicaCount: 3
  port: 1983
  secretRef:
  mqttPort: 1984
  pullPolicy: Always
  securityContext:
  # TODO Make sure we can run the image as non root user
  #  runAsNonRoot: true
    allowPrivilegeEscalation : false
  resources:
    requests:
      memory: "200Mi"
      cpu: "200m"
  readinessProbe:
    httpGet:
      path: /readiness
      port: instrumentation
  podLabels: {}
  podSecurityContext: {}
  volumes: []
  volumeMounts: []
  nodeSelector: {}
  tolerations: []
  affinity: {}
  # serviceAccount controls whether an individual service account should be created for the server.
  # If create is set to true, a name must be specified.
  serviceAccount:
    create: false
    name: "spacelift-server"
    automount: true
    annotations: {}
  lifecycle: {}

drain:
  replicaCount: 3
  secretRef:
  pullPolicy: Always
  securityContext:
  # TODO Make sure we can run the image as non root user
  #  runAsNonRoot: true
    allowPrivilegeEscalation : false
  resources:
    requests:
      memory: "100Mi"
      cpu: "100m"
  startupProbe:
    httpGet:
      path: /startup
      port: instrumentation
  podLabels: {}
  podSecurityContext: {}
  volumes: []
  volumeMounts: []
  nodeSelector: {}
  tolerations: []
  affinity: {}
  # serviceAccount controls whether an individual service account should be created for the drain.
  # If create is set to true, a name must be specified.
  serviceAccount:
    create: false
    name: "spacelift-drain"
    automount: true
    annotations: {}
  lifecycle: {}

scheduler:
  replicaCount: 3
  pullPolicy: Always
  securityContext:
  # TODO Make sure we can run the image as non root user
  #  runAsNonRoot: true
    allowPrivilegeEscalation : false
  resources:
    requests:
      memory: "50Mi"
      cpu: "50m"
  startupProbe:
    httpGet:
      path: /startup
      port: instrumentation
  podLabels: {}
  podSecurityContext: {}
  volumes: []
  volumeMounts: []
  nodeSelector: {}
  tolerations: []
  affinity: {}
  # serviceAccount controls whether an individual service account should be created for the scheduler.
  # If create is set to true, a name must be specified.
  serviceAccount:
    create: false
    name: "spacelift-scheduler"
    automount: true
    annotations: {}
  lifecycle: {}

vcsGateway:
  enabled: false
  # Domain for external VCS Gateway endpoint (required when enabled)
  # Format: hostname without protocol and port (e.g., "vcs-gateway.mycorp.com")
  domain: ""
  replicaCount: 3
  # Container ports
  externalPort: 1984  # gRPC port for remote VCS agents exposed via a load balancer
  internalPort: 1985  # HTTP port for internal usage from server/drain. not exposed, just used internally via service discovery (service-to-service).
  secretRef: ""
  pullPolicy: Always
  securityContext:
    allowPrivilegeEscalation: false
  resources:
    requests:
      memory: "100Mi"
      cpu: "100m"
    limits: {}
  podLabels: {}
  podAnnotations: {}
  podSecurityContext: {}
  volumes: []
  volumeMounts: []
  nodeSelector: {}
  tolerations: []
  affinity: {}
  # serviceAccount controls whether an individual service account should be created for the VCS Gateway.
  # If create is set to true, a name must be specified.
  serviceAccount:
    create: false
    name: "spacelift-vcs-gateway"
    automount: true
    annotations: {}
  lifecycle: {}
  ingress:
    enabled: true
    ingressClassName: ""
    annotations:
      # For AWS ALB, use these:
      # alb.ingress.kubernetes.io/backend-protocol-version: GRPC
      # alb.ingress.kubernetes.io/healthcheck-protocol: HTTP
      # alb.ingress.kubernetes.io/healthcheck-path: /grpc.health.v1.Health/Check
      # alb.ingress.kubernetes.io/healthcheck-port: traffic-port
      # alb.ingress.kubernetes.io/success-codes: "0"

cloudSqlProxy:
  enabled: false
  image: gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.11.4
  dbConnectionName:
  resources:
    requests:
      memory: "200Mi"
      cpu:    "100m"

# Whether to create a single service account that all the services should use.
serviceAccount:
  create: true
  name: "spacelift-backend"
  automount: true
  annotations: {}

service:
  type: ClusterIP
  port: 80

mqttService:
  type: ClusterIP
  port: 1984
  annotations: {}

ingress:
  enabled: true
  ingressClassName: ""
  annotations:
    # https://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size
    nginx.ingress.kubernetes.io/proxy-body-size: "0"

ingressV6:
  enabled: true
  annotations:
    # https://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size
    nginx.ingress.kubernetes.io/proxy-body-size: "0"

nameOverride: ""
fullnameOverride: "spacelift"
